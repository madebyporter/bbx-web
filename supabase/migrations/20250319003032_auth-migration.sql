-- Drop existing foreign key constraints
ALTER TABLE resources DROP CONSTRAINT IF EXISTS resources_submitted_by_fkey;
ALTER TABLE resources DROP CONSTRAINT IF EXISTS resources_owner_id_fkey;

-- Drop existing policies
DROP POLICY IF EXISTS "Admins can update resources" ON resources;
DROP POLICY IF EXISTS "Anyone can view public resources" ON resources;
DROP POLICY IF EXISTS "Only admins can insert resources" ON resources;
DROP POLICY IF EXISTS "Only admins can update resources" ON resources;

-- Update resources table to reference auth.users
ALTER TABLE resources
ADD CONSTRAINT resources_submitted_by_fkey 
FOREIGN KEY (submitted_by) REFERENCES auth.users(id) ON DELETE SET NULL;

ALTER TABLE resources
ADD CONSTRAINT resources_owner_id_fkey 
FOREIGN KEY (owner_id) REFERENCES auth.users(id) ON DELETE SET NULL;

-- Create user_profiles table
CREATE TABLE IF NOT EXISTS public.user_profiles (
    id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    username text UNIQUE,
    display_name text,
    bio text,
    website text,
    avatar_url text,
    user_type text CHECK (user_type IN ('producer', 'engineer', 'writer', 'performer', 'other')),
    social_links jsonb DEFAULT '{}'::jsonb,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Create user_resources table (for "I Use This" functionality)
CREATE TABLE IF NOT EXISTS public.user_resources (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    resource_id bigint REFERENCES resources(id) ON DELETE CASCADE,
    used_at timestamptz DEFAULT now(),
    UNIQUE(user_id, resource_id)
);

-- Create user_collections table
CREATE TABLE IF NOT EXISTS public.user_collections (
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    resource_id bigint REFERENCES resources(id) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),
    PRIMARY KEY (user_id, resource_id)
);

-- Set up Row Level Security (RLS)
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_resources ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE resources ENABLE ROW LEVEL SECURITY;

-- Create RLS policies

-- User Profiles policies
CREATE POLICY "Users can view all profiles"
  ON public.user_profiles FOR SELECT
  USING (true);

CREATE POLICY "Users can update their own profile"
  ON public.user_profiles FOR UPDATE
  USING (auth.uid() = id);

CREATE POLICY "Users can insert their own profile"
  ON public.user_profiles FOR INSERT
  WITH CHECK (auth.uid() = id);

-- User Resources policies
CREATE POLICY "Users can view their own resource usage"
  ON public.user_resources FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own resource usage"
  ON public.user_resources FOR ALL
  USING (auth.uid() = user_id);

-- User Collections policies
CREATE POLICY "Users can view their own collections"
  ON public.user_collections FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own collections"
  ON public.user_collections FOR ALL
  USING (auth.uid() = user_id);

-- Resources policies
CREATE POLICY "Anyone can view public resources"
  ON public.resources FOR SELECT
  USING (is_public = true OR auth.uid() = owner_id);

CREATE POLICY "Only admins can insert resources"
  ON public.resources FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM auth.users 
      WHERE id = auth.uid() 
      AND (raw_app_meta_data->>'roles')::jsonb ? 'admin'
    )
  );

CREATE POLICY "Only admins can update resources"
  ON public.resources FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM auth.users 
      WHERE id = auth.uid() 
      AND (raw_app_meta_data->>'roles')::jsonb ? 'admin'
    )
  );

-- Create function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.user_profiles (
    id,
    username,
    display_name,
    avatar_url,
    user_type,
    social_links,
    created_at,
    updated_at
  ) VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'username', split_part(NEW.email, '@', 1)),
    COALESCE(NEW.raw_user_meta_data->>'full_name', split_part(NEW.email, '@', 1)),
    COALESCE(NEW.raw_user_meta_data->>'avatar_url', ''),
    'other',
    '{}'::jsonb,
    NOW(),
    NOW()
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for new user creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
